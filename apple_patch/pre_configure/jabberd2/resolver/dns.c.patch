--- /tmp/jabberd-2.1.24.1/resolver/dns.c	2008-04-27 02:57:39.000000000 -0700
+++ ./jabberd2/resolver/dns.c	2008-11-24 14:21:54.000000000 -0800
@@ -21,9 +21,6 @@
 #include "resolver.h"
 #include "dns.h"
 
-/* Mac OS X 10.3 needs this - I don't think it will break anything else */
-#define BIND_8_COMPAT (1)
-
 #include <string.h>
 #include <stdlib.h>
 
@@ -49,6 +46,39 @@
 # include <windns.h>
 #endif
 
+typedef struct {
+        unsigned        id :16;         /* query identification number */
+#if BYTE_ORDER == BIG_ENDIAN
+                        /* fields in third byte */
+        unsigned        qr: 1;          /* response flag */
+        unsigned        opcode: 4;      /* purpose of message */
+        unsigned        aa: 1;          /* authoritive answer */
+        unsigned        tc: 1;          /* truncated message */
+        unsigned        rd: 1;          /* recursion desired */
+                        /* fields in fourth byte */
+        unsigned        ra: 1;          /* recursion available */ 
+        unsigned        unused :3;      /* unused bits (MBZ as of 4.9.3a3) */
+        unsigned        rcode :4;       /* response code */
+#endif
+#if BYTE_ORDER == LITTLE_ENDIAN || BYTE_ORDER == PDP_ENDIAN
+                        /* fields in third byte */
+        unsigned        rd :1;          /* recursion desired */
+        unsigned        tc :1;          /* truncated message */
+        unsigned        aa :1;          /* authoritive answer */
+        unsigned        opcode :4;      /* purpose of message */
+        unsigned        qr :1;          /* response flag */
+                        /* fields in fourth byte */ 
+        unsigned        rcode :4;       /* response code */ 
+        unsigned        unused :3;      /* unused bits (MBZ as of 4.9.3a3) */
+        unsigned        ra :1;          /* recursion available */
+#endif                  
+                        /* remaining bytes */
+        unsigned        qdcount :16;    /* number of question entries */
+        unsigned        ancount :16;    /* number of answer entries */ 
+        unsigned        nscount :16;    /* number of authority entries */
+        unsigned        arcount :16;    /* number of resource entries */
+} HEADER;
+
 
 /* compare two srv structures, order by priority then by randomised weight */
 static int _srv_compare(const void *a, const void *b) {
@@ -74,17 +104,9 @@ static int _srv_compare(const void *a, c
 /* unix implementation */
 #if defined(HAVE_RES_QUERY) || defined(HAVE___RES_QUERY)
 
-/* older systems might not have these */
-#ifndef T_SRV
-# define T_SRV (33)
-#endif
-#ifndef T_AAAA
-# define T_AAAA (28)
-#endif
-
 /* the largest packet we'll send and receive */
-#if PACKETSZ > 1024
-# define MAX_PACKET PACKETSZ
+#if NS_PACKETSZ > 1024
+# define MAX_PACKET NS_PACKETSZ
 #else
 # define MAX_PACKET (1024)
 #endif
@@ -97,7 +119,7 @@ typedef union {
 static void *_a_rr(dns_packet_t *packet, unsigned char *eom, unsigned char **scan) {
     struct in_addr in;
 
-    GETLONG(in.s_addr, *scan);
+    NS_GET32(in.s_addr, *scan);
     in.s_addr = ntohl(in.s_addr);
 
     return strdup(inet_ntoa(in));
@@ -129,9 +151,9 @@ static void *_srv_rr(dns_packet_t *packe
     char host[256];
     dns_srv_t srv;
 
-    GETSHORT(priority, *scan);
-    GETSHORT(weight, *scan);
-    GETSHORT(port, *scan);
+    NS_GET16(priority, *scan);
+    NS_GET16(weight, *scan);
+    NS_GET16(port, *scan);
 
     len = dn_expand(packet->buf, eom, *scan, host, 256);
     if (len < 0)
@@ -170,15 +192,15 @@ dns_host_t dns_resolve(const char *zone,
     switch(query_type)
     {
         case DNS_QUERY_TYPE_A:
-            t_type = T_A;
+            t_type = ns_t_a;
             break;
 
         case DNS_QUERY_TYPE_AAAA:
-            t_type = T_AAAA;
+            t_type = ns_t_a6;
             break;
 
         case DNS_QUERY_TYPE_SRV:
-            t_type = T_SRV;
+            t_type = ns_t_srv;
             break;
 
         default:
@@ -186,7 +208,7 @@ dns_host_t dns_resolve(const char *zone,
     }
 
     /* do the actual query */
-    if((len = res_query(zone, C_IN, t_type, packet.buf, MAX_PACKET)) == -1 || len < sizeof(HEADER))
+    if((len = res_query(zone, ns_c_in, t_type, packet.buf, MAX_PACKET)) == -1 || len < sizeof(HEADER))
         return NULL;
 
     /* we got a valid result, containing two types of records - packet
@@ -207,7 +229,7 @@ dns_host_t dns_resolve(const char *zone,
         qdcount--;
         if((len = dn_expand(packet.buf, eom, scan, host, 256)) < 0)
             return NULL;
-        scan = (unsigned char *) (scan + len + QFIXEDSZ);
+        scan = (unsigned char *) (scan + len + NS_QFIXEDSZ);
     }
 
     /* create an array to store the replies in */
@@ -228,10 +250,10 @@ dns_host_t dns_resolve(const char *zone,
         scan += len;
 
         /* extract the various parts of the record */
-        GETSHORT(type, scan);
-        GETSHORT(class, scan);
-        GETLONG(ttl, scan);
-        GETSHORT(len, scan);
+        NS_GET16(type, scan);
+        NS_GET16(class, scan);
+        NS_GET32(ttl, scan);
+        NS_GET16(len, scan);
 
         /* skip records we're not interested in */
         if(type != t_type) {
@@ -251,15 +273,15 @@ dns_host_t dns_resolve(const char *zone,
         /* type-specific processing */
         switch(type)
         {
-            case T_A:
+            case ns_t_a:
                 reply[an]->rr = _a_rr(&packet, eom, &scan);
                 break;
 
-            case T_AAAA:
+            case ns_t_a6:
                 reply[an]->rr = _aaaa_rr(&packet, eom, &scan);
                 break;
 
-            case T_SRV:
+            case ns_t_srv:
                 reply[an]->rr = _srv_rr(&packet, eom, &scan);
                 break;
 
@@ -281,7 +303,7 @@ dns_host_t dns_resolve(const char *zone,
     }
 
     /* sort srv records them */
-    if(t_type == T_SRV)
+    if(t_type == ns_t_srv)
         qsort(reply, an, sizeof(dns_host_t), _srv_compare);
 
     /* build a linked list out of the array elements */
